Introduction and Analysis of algorithms

------------Selection Sort-----------
step 1: Go through the unsorted part of the array to find the smallest element (In the first run, sorted part's number of element is 0)
step 2: Swap the smallest element in step 1 with the first element behind sorted part
step 3: Move the boundary between sorted part and unsorted part by one position toward the end of array
step 3: If the number of sorted part's element is not equal to the number of element in the array, go back to step 1, else the given array is sorted

------------Insertion Sort------------
step 1: Pick the first element (As there's just one element, the sorted part's number of element will be 1)
step 2: Pick the first element behind the sorted part
step 3: Use binary search to find the right position for picked element in the sorted part
step 4: Insert the element into the sorted part with the position found in step 3
step 5: Move the boundary between sorted part and unsorted part by one position toward the end of array
step 6: If the number of sorted part's element is not equal to the number of element in the array, go back to step 2, else the given array is sorted

------------Merge Sort------------

------------Bubble Sort------------

------------Heap Sort------------

------------Merge Sort------------

------------Quick Sort------------

------------Quick Sort------------

------------Radix Sort------------

------------Shaker Sort------------

------------Shell sort------------
D1. [Loop on s.] Perform step D2 for s = t − 1, t − 2, . . ., 0; then
terminate the algorithm.
D2. [Loop on j.] Set h ← hs, and perform steps D3 through D6 for h
< j ≤ N. (We will use a straight insertion method to sort elements
that are h positions apart, so that Ki ≤ Ki+h for 1 ≤ i ≤ N − h.
Steps D3 through D6 are essentially the same as steps S2 through
S5, respectively, in Algorithm S.)
D3. [Set up i, K, R.] Set i ← j − h, K ← Kj, R ← Rj.
D4. [Compare K : Ki.] If K ≥ Ki, go to step D6.
D5. [Move Ri, decrease i.] Set Ri+h ← Ri, then i ← i − h. If i > 0, go
back to step D4.
D6. [R into Ri+h.] Set Ri+h ← R

------------Counting Sort------------
step 1: 


------------Flash Sort------------